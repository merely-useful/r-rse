# Setting up an R package {#package-setup}

- Describing what a package is and when or why to make one
    - Use [available](https://github.com/r-lib/available) to make a name (naming is hard).
- Using devtools, usethis for development
    - e.g. `use_devtools()` and `use_usethis()`.
- Developing functions
- Basic explanation of what a function is and its components
- Making and using datasets
- Downloading zipf data at this point, using `usethis::use_data_raw()`, write the script to download the data and process into `data/` via `usethis::use_data()`.

## Learning Objectives

* Identify when to create an R package
* Create a new R package using `usethis::create_package()`
* Describe the purpose of the folders and files in a skeleton R package
* Add data to an R package
* Set global defaults to ease package development with devtools and usethis

## About Zipf's Law

TODO: Not sure this belongs here.

We'll create a package (`zipfs`) to analyze a fascinating result in the field of
quantitative linguistics. Zipf's Law states that the second most common word in
a body of text appears half as often as the most common, the third most common
appears a third as often, and so on. To test whether Zipf's Law holds for a
collection of classic novels that are freely available from Project Gutenberg,
we will write a software package that counts and analyzes the word frequency
distribution in any arbitrary body of text.

## Why create an R package?

The main aim of developing software, and this applies to software development in
R as well, is to simplify some task or a set of tasks for yourself and for
others (like your team). And creating an R package is one of the more powerful
ways of simplifying tasks, no matter how simple or complex to begin with.

TODO: Add a connecting paragraph or sentence...

How do you determine if you should make an R package? Ask these questions to
yourself. Have you ever made a function, no matter how simple? Have you ever
used that function more than once across more than one project or file, either
by copying and pasting it or by sourcing the file that contains it? If you
answered yes to these two questions, than you should make an R package for that
function. But you might wonder, why make a package with only one function?
Because it never stops with *just* one function, you will very likely be making
more in your work. Aside from packaging up R functions, if you have small to
medium sized datasets that you use across multiple projects or files, you can
even package up data.

Aside from a "yes" to these questions, making an R package now is much easier
than it was in the past. That's largely thanks to R packages like
[devtools][pkg-devtools] and [usethis][pkg-usethis] that are designed to simplify
developing R packages. Combined with these packages, there are also so many
free, online books and resources for learning how to make R packages and doing
software development in R (LINK).

TODO: Include link to resources section for r packages book, mastering software dev etc.

If we go back to the big picture in the preface (\@ref(#big-picture)), creating
an R package (that is posted on GitHub or submitted to CRAN) connected to scientific
work or analyses will usually fulfill the reproducibility and open science
components of research. That's because making an R package usually requires a higher
level of rigor, testing, documentation, and inspection of the code, which means
you and others will have more trust in the results. And if its on GitHub, it's
much easier to share your work with others and have a bigger impact on research
overall.

<!-- * Other advantages? -->
<!--     * Easy for other people to obtain and install -->
<!--     * Built-in documentation of functions and data -->
<!--     * Incorporate package-level meta data: authors, version, etc. -->

## What is an R package?

To understand what an R package is, we'll take a step back and consider what 
happens when we interact with R. The very basic, low-level use of R is through
the R Console where you type functions in R to do tasks that print to the screen.
This initial R Console operates in your computer's user home directory, usually
something that looks like `/home/username/` for Linux, `/Users/username/` for
macOS, or `C:\Users\username` for Windows. So any data or graphs that you save
or import needs to include the file path to the right location. From a
reproducible and modular point of view, this is goes against best practices.
Likewise, the R code entered into this session while in the Console is not saved[^r-history]
So, you cannot easily re-use or share R code when it is used this way.

[^r-history]: Well, technically you can see the history by default in a file,
but this stores *everything* you've entered into the R Console, including
wrong code. 

TODO: Image here that describes this a bit more?

The next level up is to save code in an R script (a file stored anywhere on the
computer that end in `.R`) and get R to run this code in sequence. In the past,
people might write R scripts in text editors like vim, emacs, or Notepad, and
manually run the script in the R Console. Now, you'll mostly encounter people
use an IDE (REF LINK) like RStudio to do this work instead. This is the most
commonly used approach to doing any type of work in R. Theoretically, code
written in this way is reproducible and can be shared. However, practically,
often R code in these files is written out of sequence since researchers work
with R more interactively rather than programmatically. And the working
directory (REF LINK) of an R script changes depending on how it is used, so we
still encounter similar issues as if we used the R Console on its own.
You can use clever tricks to store commonly used R code or functions in an R script
and `source()` these files from other scripts, among many other tricks. In essence,
this involves keeping track of R files across your computer to be able to do your
work.

An R package is not much different from using several R scripts. There are
certain expectations and conventions that must be followed in order for it to
be "installed" on your computer as a R package. Some of these conventions include:

- There must be a file called `DESCRIPTION` what contains metadata necessary
for R to know how to install the package. We'll cover what the fields should
have in Section TODO: REF.

- There must be an `R/` folder. This will usually contain only `.R` files
and usually they contain only R functions you've created.

- The folder with the R code should be named the same as the package name. For
instance, the R package usethis has the folder name of `usethis`. This is not
an explicit requirement, but is highly recommended. R determines the
name of the package from the `Package:` field in the `DESCRIPTION` file.

None of this is something you really have to worry about because the packages
usethis and devtools are designed to do many of these package setup tasks 
easier for you.

So how does package installing work? When you tell R to install a package, which
is a set of files and folder that follow a specific convention, R takes the
folder and converts it into its own special format. Then R saves this special
format into a default location that is specific to the operating system,
like macOS, Windows, or Linux. To see where packages are installed, use:

```{r}
.libPaths()
```

If you type this out on in your Console, what you see will probably be a bit different
to this. If `.libPaths()` outputs more than one path, usually the first will
contain all of the packages. Let's use the fs package to explore this folder.
First, let us see *some* of the packages that are installed but using `dir_ls()`.

```{r}
library(fs)
packages <- dir_ls(path(.libPaths()[1]))

# Number of installed packages
length(packages)
# See the first few package names
head(packages)
```

If we want to see how R stores packages, in there special format, we can use
`dir_tree()` and look inside the installed `fs/` package folder.

```{r}
dir_tree(path(.libPaths()[1], "fs"))
```

See the `R/fs.rdb` and `R/fs.rdx` files? These are the special formats that contain
the functions within fs that R will look for when you load the fs package.
When a package is installed in R, what that means is it is found in the R library
folder given by `.libPaths()` with the files in the R specific format. So 
when you run `library(fs)`, R will know to search for the functions found in the 
`fs/` package folder. 

So, installing your own package that is only found on your computer is no different
from installing a package from CRAN with `install.packages()` or from GitHub
with `remotes::install_github()`. The only difference is that packages on 
CRAN or GitHub (from a public repository) are usable to anyone who can access
the Internet.
    
### Exercise: Install a package from GitHub {#ex-install-github-package}

Since we make heavy use of usethis for building R packages, let's get
a bit familiar with it. Open up the 
[GitHub repository for usethis](https://github.com/r-lib/usethis)
and complete these tasks.

1. Find which file contains the `create_package()` function in the 
[`R/`](https://github.com/r-lib/usethis/tree/main/R) folder. Hint, use GitHub's
"Search or jump to..." feature to find things in the repository.

2. Find out where the package name is in the `DESCRIPTION` file.

3. In your RStudio Console, use `remotes::install_github()` to install the
usethis package. View the help documentation (`?remotes::install_github`) to
learn how to use it to install the package. 

## Creating a package    

* Text: Where should your package live? What should you call your package?


* Code: `usethis::create_package()` (maybe also `available::available()`?)
    * Note about using `::` vs `library()`

```{r cs-LABEL-NAME}
# Code used in section and shown to learners
```

```{r ce-LABEL-NAME}
# If needed. Code used in section, NOT shown to learners, but needed for auto building of package/book
```

* Text: `DESCRIPTION` is structured text that describes package, 
`R/` for R script files that define functions in the package. 

### Exercise: Exercise Name {#ex-EXERCISE-TAG}

* Exercise: Repeat steps, e.g. `usethis::create_package("zipfs")`, 
edit `DESCRIPTION` to have you as author.
 
1. Summary of steps to do in exercise

```{r es-LABEL-NAME}
# Code for exercise and shown to learner
```

```{r ee-LABEL-NAME}
# If needed. Code for exercise, NOT shown to learner, used for auto building of package/book
```

```{r sol-LABEL-NAME}
# Code for exercise *solution*, NOT shown to learner, (maybe) used for auto building of package/book
```

## R settings that help you as a developer
    
* Text: `usethis::` `devtools::` get tiresome to type.  Setup to always load.

```{r cs-LABEL-NAME}
usethis::use_devtools()
usethis::use_usethis()
```

* Text: When we restart R, want nothing in environment, no packages loaded, etc.

TODO: Fix up, this was copied from r-cubed.
Now that we’ve created a project and associated folders, let’s add some more
options to the project. One option to set is to ensure that every R session you
start with is a "blank slate", meaning no old data are automatically imported
into the Environment. This is done by typing the following code in the Console:

```{r cs-LABEL-NAME}
use_blank_slate()
```

* Text: Other configuration, e.g. to automatically populate `DESCRIPTION`:  https://usethis.r-lib.org/articles/articles/usethis-setup.html#store-default-values-for-description-fields-and-other-preferences
    
## Package development workflow
    
* Text: As an example, add a function to this package. 
Here, function is provided, next chapter, talks about how you
write functions. 

* Code: `use_r()`
```{r cs-LABEL-NAME}
# Code used in section and shown to learners
```

* Text: How do we load the function and check it works?

* Code: `devtools::load_all()`
```{r cs-LABEL-NAME}
# Code used in section and shown to learners
```
    
### Exercise: Exercise Name {#ex-EXERCISE-TAG}

* Exercise: Practice workflow. Make small edit to function, reload, 
rerun function.

1. Summary of steps to do in exercise

```{r es-LABEL-NAME}
# Code for exercise and shown to learner
```

```{r ee-LABEL-NAME}
# If needed. Code for exercise, NOT shown to learner, used for auto building of package/book
```

```{r sol-LABEL-NAME}
# Code for exercise *solution*, NOT shown to learner, (maybe) used for auto building of package/book
```


* Text: `load_all()` emulates installing and loading, but only
for current session.  Sometimes you want to actually install and load.

* Code: `devtools::install()`, `library()`
```{r cs-LABEL-NAME}
# Code used in section and shown to learners
```
    
## Adding data to a package

* Text: Data live in `data/` as `.rda` files.  

* Code: `usethis::use_data("FIXME")` Here with simplified data. Restart, `devtools::load_all()`, `FIXME`
```{r cs-LABEL-NAME}
# Code used in section and shown to learners
```

* Text: Should document how data was created. 
Put raw data and scripts that end in `usethis::use_data()` in `data-raw/`

```{r cs-LABEL-NAME}
use_data_raw()
```

### Exercise: Exercise Name {#ex-EXERCISE-TAG}

* Exercise: Provide script for getting dracula text from Gutenberg. 
Add `dracula` to package.

1. Summary of steps to do in exercise

```{r es-LABEL-NAME}
# Code for exercise and shown to learner
```

```{r ee-LABEL-NAME}
# If needed. Code for exercise, NOT shown to learner, used for auto building of package/book
```

```{r sol-LABEL-NAME}
# Code for exercise *solution*, NOT shown to learner, (maybe) used for auto building of package/book
```


    
## Final exercise

Complete these tasks as part of the package for your first project assignment.
Refer to the project assignment for exact details on what you are required to
create and on what the package should do. For this exercise, we will be using
a package about weather in Kenya as an example and reference.

1. Decide on a simple but descriptive name for your new package. Use
[available][pkg-available] to see if the name is taken.

2. Use `create_package()` to create a new package. While you can create this
package anywhere on your computer, for now we suggest either your `Desktop/` or
maybe something like `Documents/r-pkgs/`.

3. Open the `DESCRIPTION` file and update the file with:
    * Yourself as the author in the `Authors@R:` field.
    * A one sentence description of the package in the `Title:` field.
    * Two or three sentence summary of the package in the `Description:` field.

4. Add some data to the package. Use `use_data_raw()` to create the `data-raw/`
folder along with a script for cleaning the raw data. Then put the data in this
newly created folder. Write in some simple data cleaning processes in the cleaning
R script and follow the steps in Section FIXME to make the FIXME data available
as part of the package.
 
You'll know you are finished if:

* Your package can be installed with `install()` (or `Ctrl-Shift-B` to build it).
* In a fresh R session, after running `library(FIXME)` you can access the data
by its name.

TODO: Add actions done to kenyaweather package here?
