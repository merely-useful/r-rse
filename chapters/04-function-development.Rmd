# Function development in a package environment

- Process of creating non-function code, checking that it works, then
   converting it into a function
- There are several workflows for this (create in vignette Rmd, make a dev/creating.R
    script as a development location, developing in the examples Roxygen
    section, 'Untitled1.R'). Which to use?
- Mostly *how workflow actually looks like*.
- Building functions up slowly, making small targeted functions that build up
  into a bigger more complex functions
- Process control (if, stop)
- Dependency management (better term? e.g. using `@importFrom` vs `::`)

TODO: should this be here or later?

- Function documentation (with roxygen2), part 1
- To use `@examples` to help with creating function

## Learning Objectives

* Convert a chunk of R code into a function
* Include a function in an R package
* Provide basic function documentation using Roxygen
* Use functions from other packages in a function in your own package
* Return an error message from a function

## Writing Functions in R

* Review current state of package

```{r cs-dracula-meta}
load_all()
dracula[8:14]
```
```
> load_all()
â„¹ Loading zipfs
> dracula[8:14]
[1] ""                                          
[2] "Title: Dracula"                            
[3] ""                                          
[4] "Author: Bram Stoker"                       
[5] ""                                          
[6] "Release Date: August 16, 2013 [EBook #345]"
[7] ""   
```

* Goal: extract meta data
* Writing a function starts with working chunk of code. 

```{r ce-load-zipfs}
# Needed to get data for now...
library(zipfs)
```

* Start with some working code. 
(We are providing working code here, but usually this is the hardest part!)

```{r cs-extract-meta, eval = FALSE}
library(stringr)
library(tibble)

text <- dracula[8:14]

author_line <- str_subset(text, "Author: ")
author <- str_remove(author_line, "Author: ")

title_line <- str_subset(text, "Title: ")
title <- str_remove(title_line, "Title: ")

release_date_line <- str_subset(text, "Release Date: ")
release_date <- str_remove(release_date_line, "Release Date: ")

tibble(
  author = author, 
  title = title,
  release_date = release_date
)
```
* Where can I write this code, so it doesn't interfere with package
conventions? 

```{r cs-setup-dev-dir}
use_directory("dev", ignore = TRUE)
```

* Save above chunk in `dev/creating.R`

* Identify repetition in above code: x3
```
line <- str_subset(text, XXX)
value <- str_remove(line, XXX)
```

* Review how to turn code into a function: pick a name, identify arguments, 
fill in the function constructor.  

```{r cs-extract-element}
extract_element <- function(text, element){ 
  line <- str_subset(text, element)
  value <- str_remove(line, element)
  value
}
extract_element(text, "Author: ")
```

* Explicit vs implicit returns?

```{r cs-implicit-return}
extract_element <- function(text, element){
  line <- str_subset(text, element)
  str_remove(line, element)
}
extract_element <- function(text, element){
  line <- str_subset(text, element)
  value <- str_remove(line, element)
  return(value)
}
```

* Updated chunk
```{r cs-updated-chunk}
library(stringr)
library(tibble)

text <- dracula[8:14]

tibble(
  author = extract_element(text, "Author: "), 
  title =  extract_element(text, "Title: "),
  release_date = extract_element(text, "Release Date: ")
)
```

### Exercise: Write `book_meta()` {#ex-write-book-meta} 

Write the `book_meta()` function.

This is how we'd like our chunk to look:
```{r es-book-meta}
library(stringr)
library(tibble)

text <- dracula[8:14]
book_meta(text)
```

```{r sol-book-meta}
book_meta <- function(text){
  tibble(
    author = extract_element(text, "Author: "), 
    title =  extract_element(text, "Title: "),
    release_date = extract_element(text, "Release Date: ")
  )
}
```

## Including Functions in an R Package

Current contents of `dev/creating.R`
```{r cs-creating-contents}
library(stringr)
library(tibble)
load_all() # I don't think we've `install()`ed yet?

text <- dracula[8:14]

extract_element <- function(text, element){ 
  line <- str_subset(text, element)
  value <- str_remove(line, element)
  value
}

book_meta <- function(text){
  tibble(
    author = extract_element(text, "Author: "), 
    title =  extract_element(text, "Title: "),
    release_date = extract_element(text, "Release Date: ")
  )
}

book_meta(text)
```

* Text: Functions live in `.R` files in `R/`.
How should functions be organized into files?

```{r cs-create-code-file}
use_r("book-meta")
```

* Text: move function definitions into `R/book-meta`

```{r cs-contents-book-meta}
extract_element <- function(text, element){ 
  line <- str_subset(text, element)
  value <- str_remove(line, element)
  value
}

book_meta <- function(text){
  tibble(
    author = extract_element(text, "Author: "), 
    title =  extract_element(text, "Title: "),
    release_date = extract_element(text, "Release Date: ")
  )
}
```

* Text: Now, `load_all()` loads our function definitions too. 

```{r cs-updated-creating-contents}
library(stringr)
library(tibble)
load_all() # I don't think we've `install()`ed yet?
book_meta(dracula) # notice this is now all lines 
```

### Exercise: Write `count_words()` based on chunk

Might put code in `dev/counting.R`
```{r es-count-words-chunk}
library(stringr)
library(tibble)
library(zipfs)

# convert to all lower
text_lower <- str_to_lower(dracula) 

# split by one or more whitespace characters
chunks <- unlist(str_split(text_lower, "\\s+"))

# remove punctuation
words <- str_remove_all(chunks, pattern = "[[:punct:]]+")

# get rid of empty strings
words <- words[words != ""]

# count occurrences and sort
word_freq <- sort(table(words), decreasing = TRUE)

# return in rectangular format
tibble(word = names(word_freq), n = as.numeric(word_freq))
```

Reminder of steps:

* Convert chunk into function in `dev/counting.R`. Check it works `count_words(dracula)`
* Create new file in `R/` called `count-words.R`, copy over definition
* Check work by editing code in `dev/counting.R` to 
```{r es-check-count}
library(stringr)
library(tibble)
library(zipfs)

count_words(dracula)
```
    
## Dependencies: Using Functions From Other Packages

* Text: We have a problem.  On clean session, `load_all()`, 
`book_meta(dracula)`, produces an error, 
can't find `tibble()`. Difference between interactive work (`library(tibble)`)
and package development (don't want to load entire libraries in user's workspaces)

```{r cs-dep-error, error = TRUE}
# Restart R, clean slate
load_all()
book_meta(dracula)
```

* Text: Two changes needed: specify our package relies on another, 
inside functions, be specific about where functions inside our own code come from.
* Code: `use_package("tibble")`, `tibble::tibble()`
* Exercise: Fix dependency problems in `extract_element()`.
* Text: The pipe needs slightly more complicated handling.
* Code: `use_pipe()`
* Exercise: Fix dependency problems in `count_words()`.

## Documenting Functions

* Text: Outline of Roxygen workflow: special comments above functions + `document()`, 
generates `man/` and allows `?function_name`
* Code: With `book_meta()` RStudio: Code -> Insert ROxygen Skeleton, `document()`, `?book_meta()`
* Text: Common Roxygen tags (title, arguments, return, examples), demo with `book_meta()`
* Exercise: Document `count_words()`
* Text: `@export`, why we might not document every function.

* Stopping Your Function with an Error
* Text: Alternate workflow for editing functions, 
use `@examples`, edit directly in `R/book-meta.R`. 
Add `book_meta(1)` as example.
<!-- This will cause a check error later, because examples need to run without error. -->
* Text: Basic checks of user input, how to return an error
* Code: `if()`, `stop()`
* Exercise: Add an input check to `count_words()`.
* Text: Re-iterate idea of extracting common code into simpler functions.
Suggest input check could be its own function.
* Text: Mention other kinds of process control, give pointer to learn more.
  

## Final exercise {#04-final-exercise}

TODO: INCOMPLETE, need to think about this more.

Complete these tasks as part of the package for your first project assignment.
The exact functions you should create will depend heavily on what your package
will do. Get help and guidance from your instructor. Use our examples on the 
`kenyaweather` package as further guidance.

1. Create a new R script using `use_r("..")`

1. Add a `FIXME()` function to your FIXME package
    
    The following code snippet produces ... FIXME.  
    
    ```{r, eval = FALSE}
    # A line or two of R code that does something useful
    FIXME
    ```
    
    Turn it into a function called `FIXME()` that takes arguments for `FIXME`
    and `FIXME` and include it in your FIXME package.
    
    Insert a Roxygen Skeleton for this function, making sure to edit the title,
    description, argument descriptions, and example. Don't forget to run
    `document()` to produce the help page.

2. Add a `FIXME2()` function to your FIXME package

    Add another function called `FIMXE2()`, that ... FIXME. It should return an
    error if FIXME. *This function is intentionlly given without a snippet of
    code so you can practice the function development workflow.*
    
    Insert a Roxygen Skeleton for this function, making sure to edit the title,
    description, argument descriptions, and example. Don't forget to run
    `document()` to produce the help page.

While you are completing these tasks, You'll know you are done when after
installing your package and starting a fresh R session:

* The following code runs without error and produces the right output

    ```{r, eval = FALSE}
    library(FIXME)
    FIXME()
    FIXME2()
    
    # Should give an error
    FIXME2()
    ```
    
* `?FIXME()` and `?FIXME2()` bring up help pages that have at least a title, a description of each argument, and at least one example of usage.

TODO: Add actions done to kenyaweather package here?


## Final exercise

<!-- NOTE: Preferably something linked to working towards completing the project assignments, maybe to be used as a milestone? -->


