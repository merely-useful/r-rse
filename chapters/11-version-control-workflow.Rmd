# Collaborating by using GitHub {#github-collaboration}

```{r setup}
library(usethis)
```

## Learning objectives {#11-learning-objectives}

- Apply concepts from basic Git workflows to working collaboratively using GitHub
- Differentiate forking and branching and identify situations when to use either
- Understand the use and role of branches and pull requests in collaborating
on a project
- Use helper functions in the usethis package to manage branches and submit pull
requests in GitHub
- Manage pull requests as a maintainer or lead of a project

## Collaborating with Git and GitHub

### Exercise: Consider ways to collaborate

Before we get into this section, let's do an exercise to start thinking about 
the different ways people have come up with so that they can collaborate together.
They range from writing files and emailing them around to using Google Drive or 
similar services.

1. Take some time to think about and write down the different ways you have
collaborated with others on a project or task. Then think about the ways that
you've heard or seen other people collaborate together.
1. Of the different approaches to collaboration that you've written down,
which of them do you feel are more effective in terms of time management,
effort, ease of use, and that best fit the needs for the project they were used it?
Would any of these methods work well when building an R package as a team?
1. Take some time and brainstorm some approaches to collaborating that you would
feel would help make an R package with others?

<!-- TODO: Have them write this down in a vignette? -->

### Forks, branches, and pull requests on GitHub {#workflows-explained}

<!-- TODO: Have silly or serious headings? :P -->

In this chapter we are going to cover a collaborative workflow that is commonly
used among software engineers and R package developers.
In Chapter \@ref(git-solo), we covered Git branches and remotes. We'll quickly
review these concepts again because they play a key role in this workflow.

- **Branches**: At a basic level, a Git branch is a label that points to a specific
commit in the Git repository. Working in a branch allows you to modify files
without modifying the same files in other branches, because you are essentially
working in a "parallel" set of files. When you want the changes made in the
branch to be put into the main branch (which is also often called "main"),
you would do this by merging the branches together. In team settings, working on
branches lets you make changes to files without impacting your other team
members work. When your changes to files are finished, you can then merge your
changes into the main branch so your other team members have those changes too.
Branches are heavily used in team-based settings in software and R
package projects.
- **Remotes**: A remote is a copy of the repository that is stored in a separate
location for your local repository. The most commonly used remotes are on Git
repository hosting services like GitHub, GitLab, and others like them.

The collaborative workflow includes two new terms and concepts: *forks* and
*pull requests*.

- **Forks**: A fork is a copy of an original repository on GitHub that is also
stored on GitHub. So both the original and fork are on GitHub.
- **Pull requests**: A pull request is a tool in GitHub that lets contributors
make changes in a fork or branch and then request that those changes get merged
into the main repository by the maintainer. Pull requests can come from forks
or from separate branches from within the repository. They let maintainers and
contributors review, discussion, request further changes, and approve the
changes for being merged into the main branch. Think of pull requests like peer
review of scientific work or collaborators reviewing a scientific report.

Learning to effectively use these tools and concepts can make collaborating with 
others much easier and makes it easier to contribute to other projects.
You can even use this workflow as a solo developer. So what is this workflow?
Figure TODO: REF and TODO: REF show the basic overview for workflows
not using or using a fork-based approach. For non-forked-based workflows, the
steps are to:

1. Create a new branch.
1. Make some edits to files and commit to the branch.
1. When the changes are done and ready, submit a pull request for the new branch
to be merged into the main branch.
1. Pull request gets either accepts and merged or changes are requested, which
require going back up to step 2.
1. After pull request gets accepted and merged, the main branch now has the updated
changes and the new branch can now be deleted.
1. Process can repeat multiple times, in parallel or in sequence depending on the
size of the team.

TODO: Diagram needs to be fixed here, this is basic skeleton

```{r fig-git-collaborative-workflow-no-forks, eval=FALSE}
DiagrammeR::grViz("digraph {
repo -> new_branch -> pr -> accepted -> repo
}")
```

For fork-based workflows, the steps are to:

1. Create a fork of the main repository (if it hasn't been forked already).
1. Optionally but strongly recommended, create a new branch in the forked repository.
1. Make edits and changes to the files and commit to the branch.
1. When ready, submit a pull request. Changes may be requested, which require going
back to step 3.
1. If the pull request gets accepted and merged, the main branch in the main
repository is now updated and the new branch in the forked repository can be
deleted.
1. The forked repository now needs to be synchronized with the main repository.

```{r fig-git-collaborative-workflow-forks, eval=FALSE}
DiagrammeR::grViz("digraph {
sami_repo -> amira_fork -> amira_new_branch -> pr_to_sami_repo -> 
    pr_accepted -> sami_repo -> synch -> amira_fork
}")
```

The main differences between using a non-forked-based approach compared to a
forked-based approach is determined by whether you have access to modify ("write
permissions") the main repository. Usually if you are in a team, you have
permissions to modify and save ("write") changes to the main repository,
so in that case you would use a non-forked-based approach.

One challenge that often comes up is knowing how and when to use the branches.
Do you do all your changes there and make pull requests to the main branch
occasionally? Do you make a branch, do a pull request, and delete it right
after? What changes do you make in the new branch? These and many more are great
questions to ask and are also difficult to answer. They depend on context, on
the team, on the package you are making, what your aims are for the package, and
so on. However, there are a few tips to give:

1. Make small, focused changes that relate to a bug or specific goal (e.g.
updating documentation to reflect a spelling change) when making
new branches and submitting pull requests. The less you change, the easier it is
for the maintainer or your team members to review and accept.
1. If you are making big changes, its best to keep the changes related to a concept
or goal so that reviewing it is at least easier to conceptually follow.
1. Make changes related to a specific Issue and write in the Issue that you are
working on it.

Let's show some examples of how you'd use the fork and non-fork based workflows
based on a few scenarios.

1. **As a solo developer**: In this scenario, you would probably be least
likely to use this workflow since you can easily work with Git without ever making
a branch. However, sometimes you might want to experiment with code or text
and don't want to modify the main branch. Here you'd use the *non-fork-based workflow*.
1. **As a solo developer with some outside contributors**: If you are working on
an open source R package and people are occasionally contributing to your package,
as the maintainer and developer you would be dealing with other peoples pull
requests rather than you doing them yourself. If your package becomes very popular,
you might start using the *non-fork-based workflow* in order to reduce the chance
that you make a change to the main branch of the package that might affect
others who are using it.
1. **As a contributor but not part of a team**: If you contribute occasionally to
an R package, you would use the *fork-based workflow*. You would fork the package's
repository, make edits in new branches, and submit pull requests so your changes
get incorporated back into the package. This particular scenario is by far the most
commonly occurring in the open source R package world, since most packages are
maintained by one or many a few other people.
1. **As a member of a team**: If you have write permissions to the repository
and are part of a team working on that repository, you would use the *non-fork-based
workflow*. You'd make changes to files by first making a branch and when you are
ready, you would submit the changes as a pull request so other team members
can review your changes.

For the rest of this chapter we'll largely focus around the third and fourth scenarios.

### Exercise: Reading and comprehension task?

<!-- For pull requests, branches, and/or remotes? -->

Consider these questions and select the most appropriate answer:

1. You are working on your team's package and create a branch to fix some bugs
in the code. Most often, you would submit a pull request when you have:
    a. Fixed the bugs.
    b. Made the first Git commit.
    c. Finished your work day.
2. You are reviewing some changes on your team's GitHub repository and make
edits to some files directly from GitHub. Later, you open RStudio and continue
writing code for your team's package. In the first case you are ___ and in the
second case you are ___. Can you explain what the difference is?
    a. 1) Working on the **remote** git repository and 2) working on the
    **local** git repository.
    b. 1) Working on the **local** git repository and 2) working on the
    **remote** git repository.

```{r sol-understand-branches-pr-forks, eval=FALSE}
# Code for exercise *solution*, NOT shown to learner, (maybe) used for auto building of package/book

# 1. Answer really is that it depends, but in general it is a), after you
# addressed the problem/bug.
# 2. Answer is a), since GitHub is on a server and is not on your computer.
```

### Exercise: What workflow do these situations need?

Consider these situations and think about the workflow you'd use for each of them.

1. You are in a class where one of the assignments is a group-based assignment
to make a software package. Which of the above workflows would be the best
approach to use to complete a project as a team? Can you think of other
approaches that might work just as well? What are some strengths and weaknesses
to each approach?
2. You are doing a MSc research project and you are mostly the only one who
works on the project. The other collaborators mainly provide intellectual
feedback and comments. What type of workflow would you use? Why? What other
workflows can you think of that might also work?
3. A friend learns that you are creating an R package in your free time and
wants to contribute. What would you tell your friend to do in order to
contribute? Which approach would work best for you, considering they may likely
work on your project occasionally and may only contribute a little bit?
4. While browsing a website for an R package, you find a few typos and decide to
fix it for them. Which of the above approaches would you use?

## Securing your GitHub

<!-- This section won't be a code along, maybe reading activity? -->

TODO: This section might be moved up to the solo section, since that is when GitHub is first used... or moved to appendix... Not sure how much I like that idea tho.

Any interaction with the Internet carries some risk to malicious activities and
threats. This is no different when using GitHub. Considering that most if not
all of your Git repositories will (now or eventually) be on GitHub, keep them
secured is a vital step when working online. Not only is it something that
should be done, but many usethis functions require these security features to be
set up in order to work. Thankfully making your GitHub account secure is a
fairly straightforward task and is made easier by the usethis functions
`gh_token_help()` and `create_github_token()`.
The usethis package website also has a really 
[well written guide][usethis-git-credentials] on setting it up.
Their (and our) basic recommendation is to:

- Use HTTPS with your GitHub TODO: explain this a bit more (e.g. vs SSH).
- Turn on two-factor authentication (2FA), which is a way of verifying
("authenticating") that it is you who is using your GitHub account. 2FA
is when you provide your password as well as a randomly generated, time-limited
code usually given by an authenticator app on your phone. Since only you 
(usually) have access to your phone and would know if it was stolen, enabling
2FA is a powerful way of immediately improving the security of your GitHub.
- Use personal access tokens (PAT, or simply called a "token") when interacting
with your GitHub remote repositories while outside of the GitHub website (e.g.
when using R or usethis). PAT's are like temporary passwords that provide limited
access to your GitHub account, like being able to read or write to your GitHub
repositories, but not being able to delete them. They are useful because you can
easily delete the PAT if you feel someone got access to it and prevent it from
being used, unlike your own password which you would have to manually change
if it was stolen.
- Use a password manager to save the PAT for later use. Using password managers
is basically a requirement for having secure online accounts, because they can 
generate random and long passwords that you don't have to remember.
- Use packages like [gitcreds][pkg-gitcreds] to give usethis access to the PAT
and to interact with your GitHub repositories. You normally would have to
use gitcreds every time you restart your computer or after a certain period of
time.
- Don't save your PAT in plain text files like `.Renviron` (which is/was often
done). Plain text files can be read by anyone, meaning there is a chance that
if someone got access to your computer either remotely or physically, they would
be able to easily see your PAT and use it. Passwords or any token should not
be stored in plain text files.

[pkg-gitcreds]: https://gitcreds.r-lib.org/
[usethis-git-credentials]: https://usethis.r-lib.org/articles/articles/git-credentials.html

These are some of the many ways of securing your GitHub and repositories. In
Chapter \ref(team-package-dev) we will cover more ways that you can improve
security of your GitHub repositories, especially within a team setting.
For now, we will expand more on these recommendations and define these new terms. Firstly, 2FA is 

Next we provide some context and a rationale for these recommendations. In the
following section, we explain how to actually implement this. 
As you go through an set up everything, get comfortable using the helper function
`git_sitrep()`, which will run some checks and give some advice when it finds
potential problems. Test it out right now in the console:

```{r ce-set-git-config-to-amira, eval=FALSE}
# TODO: need code to change working directory/project with local user name and run git_sitrep
# But this doesn't work because of sitrep uses global, not local..
# A workaround is to set the global user to be Amira in the GH Actions (e.g. `with:`)
# https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs
# TODO: Add code that detects if running on GitHub Actions, maybe an environment variable?
withr::with_dir(tempdir(),
{
    fs::file_create(".here")
    gert::git_init()
    gert::git_config_set("user.name", "Amira")
    fs::dir_ls(".", recurse = TRUE)
})
```

```{r cs-git-sitrep, eval=FALSE}
# TODO: Find a way to output into the book? Or copy and paste?
usethis::git_sitrep()
```

It outputs quite a bit of text that you can use when you encounter problems and
you aren't sure how to diagnose the problem. The second helper function is
`gh_token_help()`

```{r cs-gh-token-help}
gh_token_help()
```

This output tells you if you have a GitHub token already and what to do
to either create a new one (using `create_github_token()`) or how to access
an already existing one `gitcreds::gitcreds_set()`. 
For now, we will create a new one just in case one hasn't been created yet.

```{r cs-create-token, eval=FALSE}
create_github_token()
```

This function sends us to the GitHub "Generate new token" webpage with all the
necessary settings checked. All you need to do is click the green button at the
bottom called "Generate token" and you'll have a very long string generated
for you. **Save this token in your password manager**. This is the token you 
will use every time you open up RStudio and interact with GitHub through R.
You do **not** need to create a new token for each R project or package you
make, you only need to create one after your current token expires 
(typically every couple of months), if you've forgotten the token or lost it,
or if you've changed to a new computer.
In order for R recognize the token, you need to run the below code in the Console:

```{r cs-gitcreds-set, eval=FALSE}
gitcreds::gitcreds_set()
```

And then copy and paste your token into the prompt in the Console. The gitcreds
package typically saves this token for the day (it caches the token), but after
restarting you will need to run the action again. 

### Exercises: Consider your own computer security practices

TODO: Thoughts on these ones? Might be a bit provocative :P

Take some time to think about these questions and self-reflect on them.

1. Do you use a password manager? Why or why not? If not, what is it that is
holding you back from starting to use one?
1. Why might it be important to have more security when working on a project
as part of a team? What might happen if your GitHub account or repository was
hacked because you have poor security practices?
1. How might using a PAT make it easier for you to fix a security issue?
If you didn't use a PAT when you remotely (e.g. through RStudio) access your
GitHub repositories and instead used your GitHub password, what is the danger
if someone was able to gain access to your password? Why would using a PAT make
less dangerous if someone gained access to it instead of your password?

## Simplified collaboration with usethis

Collaborating through GitHub with forks, branches, and pull requests is
generally pretty easy when you've learned how to do use them. But even then, 
sometimes it can be a bit tedious having to click through all the clicks
to either submit a new pull request or to review, accept, and merge changes.
Thankfully, the usethis package has several helper functions specifically
designed to work with pull requests and collaborating through GitHub.
These functions all start with `pr_`, which stands for Pull Request.

What is the advantage of using the usethis PR helpers over using the GitHub 
interface? Once you learn to use these helpers, the biggest advantage is that
you will be faster at contributing to a project or dealing with contributions
since you won't have to leave RStudio. And, since the usethis functions are well
documented, you can read the help documents to remind yourself what to do and
how they work.

In Section \@ref(workflows-explained), we covered the different scenarios you'd
likely encounter while developing R packages and the accompanying workflows
you'd use. The usethis PR helpers are largely designed to help with scenarios
that involve either contributors to your project, you contributing to someone
else's project, or working within a team setting. You can also use these helpers
as a solo developer, but they are designed specifically for multi-person
contributing.

There are two roles that can be taken in these scenarios: The contributor and
the maintainer. If you are working solo, you would be the maintainer, but you'd
likely not use these helper functions if you work *entirely* solo and never
contribute at all to other R projects. Being a contributor would be when you
modify content on the repository in some way through pull requests. Being a
maintainer would be to review contributions from others in the pull requests.

In general, the usethis PR helper functions can be grouped into a few
categories based on your role. As a **contributor** they would be:

- Starting a contributing and submitting a pull request:
    - `create_from_github()`: This is only done when you start contributing to
    a package that is not yours nor is your teams. For instance, if you see a
    typo or bug in a package and want to fix it yourself, you'd first start by
    forking and cloning (downloading) the R package to your computer.
    - `pr_init()`: Start a new Git branch in the package repository on your computer,
    while in the RStudio R Project.
    - `pr_push()`: After making edits and committing them to the Git branch,
    you would start a GitHub pull request with this function.
    - `pr_pause()`: Usually pull requests are reviewed after several days (or
    weeks or months), so in the meantime you might want to stop working on the
    branch and move back to the main branch. This function will pause your work
    on the branch and move back to the main branch.
- Receiving comments or edits and making subsequent changes based on the comments:
    - `pr_view()`: While in RStudio, if you want to jump to the GitHub pull request
    webpage to view the comments made to your changes, you can quickly do that with
    this function.
    - `pr_resume()`: Since you likely used `pr_pause()` after submitting your
    pull request, you need to get back to the branch in order to start making
    more changes or addressing the comments from the pull request by using
    this function.
    - `pr_merge_main()`: Depending on how often others contribute to the repository,
    you might need to update your branch with changes that have happened in the main
    branch of the repository. This function checks if your branch has any differences
    with the branch on the computer
    happened in the
    - `pr_pull()`
    - `pr_push()`
- Having the pull request accepted and merged or to be rejected and closed:
    - `pr_finish()`
    - `pr_forget()`

- `pr_fetch()`

- As contributor/sole developer/as team
    - usethis::pr_init()
        - Make changes to Contributing about using pr helpers
    - usethis::pr_push()
    - usethis::pr_view()
    - usethis::pr_pause()
    - Exercise: Make an edit on the PR changed files using GitHubs edit interface.
    - Exercise: Create another PR for adding ...FIXME.
    - usethis::pr_resume()
    - usethis::pr_pull()
    - usethis::pr_merge_main()
    - usethis::pr_push()
    - PR has been merged
    - gert::git_branch_list() # Show list of created branches
    - usethis::pr_finish()
    - Exercise: Do the same process for the other PR you had created.
    - gert::git_branch_list() # Show list of created branches
    - usethis::pr_init()
    - usethis::pr_forget()
    - gert::git_branch_list() # Show list of created branches

**Removing a branch**

- gert::git_branch_list() # Show list of created branches
- usethis::pr_init()
- usethis::pr_forget()
- gert::git_branch_list() # Show list of created branches

### Exercise: Deleting a branch without merging

TODO: Taken from PyRSE, needs more modifying.

Create a branch called `experiment` with pr_init(). Create a new vignette
called `experiment.Rmd` with use_article(). Add your name to the YAML header.
Commit the changes and move back to main branch with pr_pause().

1.  Run pr_forget()...

### Workflows for project maintainers or team leads

- As maintainer, reviewer, team lead. (Hard to do exercises for this... need to
think how this part would be implemented/practiced.)
    - usethis::pr_view()
    - usethis::pr_fetch()
    - usethis::pr_push()
    - usethis::pr_merge_main()
    - usethis::pr_view()
    - Manually merge PR.
    - usethis::pr_finish()
    - Exercise: Conceptual, write out/describe how this process could improve
    collaboration and teamwork.

```{r, eval=FALSE}
# NOTE: This is some of the code used throughout the chapter, put in a format
# that any changes to the project can be automatically added at final book build.
library(usethis)

# create_github_token()
# gitcreds::
# TODO: Talk about security?
# gh_token_help()

# TODO: Add to CONTRIBUTING guidelines about using usethis pr
pr_init("contributing-update")

# Not added to code, but added to text. Using this so package gets built exactly
# as stated in content.
# contributing_text <- readLines(here::here("CONTRIBUTING.md")) # Yea?
contribute_pr_helpers_text <- "
TODO: Add text about using usethis
"
# writeLines(contribute_pr_helpers_text, here::here("CONTRIBUTING.md"))

# gert::git_add("CONTRIBUTING.md")
# gert::git_commit("add to use usethis pr_ helpers in contributing")

# pr_push()
# Go into GitHub and merge PR (R function to do that? pr_fetch? git_merge then
# git_push?)

# pr_init("another-branch") # TODO: other changes?
# pr_pause()
# Someone reviews the PR and accepts it
# pr_resume("another-branch")
# 
# pr_finish()
```

## Chapter summary



## Final exercise {#11-final-exercise}

Complete these tasks as part of the package for your first project assignment.
Refer to the project assignment TODO: Add ref to assignment here?
for more details. As with the other final exercises,
we will use the `kenyaweather` package as an example and reference.
Don't forget to add and commit any changes you've made into the Git history
after each task, and pushing to GitHub.

TODO: Add guidelines about using usethis::pr_ helpers? or at least link to it?

1. Create a new Issue on your package's GitHub repository about an idea for a
function or to fix an existing function (you don't have to actually fix it).
2. Using the `pr_*` helpers, create a new branch called `fixing-function` using
`pr_init("fixing-function")`.
    - Make the following changes to the FIXME function:
        - FIXME: Not really sure what to say here. Could indicate that instructor has more detailed instructions. OR maybe not. Let's come back to this.
    - Add and commit these changes.
5. Push the changes up to GitHub by using `pr_push()`.
    - Create a new Pull Request based on the push in the newly opened up GitHub
    page (this should open automatically with `pr_push()`).
    - Merge the newly created Pull Request.
6. In your local Git repository, run `pr_finish()` to finish up.

Repeat this process one more time by making changes to:

- FIXME: Adding to README maybe or one of the vignettes?

```{r, eval=FALSE}
# This is the actions done to the project package
# 1. new issue
# githubr::gh_new_issue ? or gh package?
# new_number <- githubr::gh_issue_list ?

# 2. 
# pr_init("fixing-function")

# 3. 
# TODO: What to change?

# 4.
# git_add("R/TODO")
# git_commit(str_c("update function to have TODO. Closes ", new_number))

# 5.
# pr_push()
# pr_pause()
# git_merge("fixing-function")
# git_push() ?
# pr_resume("fixing-function")
# pr_finish()
```

### Exercises for second project assignment?

