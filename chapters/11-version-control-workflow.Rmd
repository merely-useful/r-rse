# Collaborating by using GitHub {#github-collaboration}

```{r setup}
library(usethis)
```

## Learning objectives {#11-learning-objectives}

- Apply concepts from basic Git workflows to working collaboratively using GitHub
- Differentiate forking and branching and identify situations when to use either
- Use helper functions in the usethis package to submit pull requests in GitHub
- Manage pull requests as a maintainer or lead of a project

## Collaborating with Git and GitHub

### Exercise: Ways to collaborate

Before we get into this section, let's do an exercise to start thinking about 
the different ways people have come up with so that they can collaborate together.
They range from writing files and emailing them around to using Google Drive or 
similar services.

1. Take some time to think about and write down the different ways you have
collaborated with others on a project or task. Then think about the ways that
you've heard or seen other people collaborate together.
1. Of the different approaches to collaboration that you've written down,
which of them do you feel are more effective in terms of time management,
effort, ease of use, and that best fit the needs for the project they were used it?
Would any of these methods work well when building an R package as a team?
1. Take some time and brainstorm some approaches to collaborating that you would
feel would help make an R package with others?

<!-- TODO: Have them write this down in a vignette? -->

### Forks, branches, and pull requests on GitHub {#workflows-explained}

<!-- TODO: Have silly or serious headings? :P -->

In this chapter we are going to cover a collaborative workflow that is commonly
used among software engineers and R package developers.
In Chapter \@ref(git-solo), we covered Git branches and remotes. We'll quickly
review these concepts again because they play a key role in this workflow.

- **Branches**: At a basic level, a Git branch is a label that points to a specific
commit in the Git repository. Working in a branch allows you to modify files
without modifying the same files in other branches, because you are essentially
working in a "parallel" set of files. When you want the changes made in the
branch to be put into the main branch (which is also often called "main"),
you would do this by merging the branches together. In team settings, working on
branches lets you make changes to files without impacting your other team
members work. When your changes to files are finished, you can then merge your
changes into the main branch so your other team members have those changes too.
Branches are heavily used in team-based settings in software and R
package projects.
- **Remotes**: A remote is a copy of the repository that is stored in a separate
location for your local repository. The most commonly used remotes are on Git
repository hosting services like GitHub, GitLab, and others like them.

The collaborative workflow includes two new terms and concepts: *forks* and
*pull requests*.

- **Forks**: A fork is a copy of an original repository on GitHub that is also
stored on GitHub. So both the original and fork are on GitHub.
- **Pull requests**: A pull request is a tool in GitHub that lets contributors
make changes in a fork or branch and then request that those changes get merged
into the main repository by the maintainer. Pull requests can come from forks
or from separate branches from within the repository. They let maintainers and
contributors review, discussion, request further changes, and approve the
changes for being merged into the main branch. Think of pull requests like peer
review of scientific work or collaborators reviewing a scientific report.

Learning to effectively use these tools and concepts can make collaborating with 
others much easier and makes it easier to contribute to other projects.
You can even use this workflow as a solo developer. So what is this workflow?
Figure TODO: REF and TODO: REF show the basic overview for workflows
not using or using a fork-based approach. For non-forked-based workflows, the
steps are to:

1. Create a new branch.
1. Make some edits to files and commit to the branch.
1. When the changes are done and ready, submit a pull request for the new branch
to be merged into the main branch.
1. Pull request gets either accepts and merged or changes are requested, which
require going back up to step 2.
1. After pull request gets accepted and merged, the main branch now has the updated
changes and the new branch can now be deleted.
1. Process can repeat multiple times, in parallel or in sequence depending on the
size of the team.

TODO: Diagram needs to be fixed here, this is basic skeleton

```{r fig-git-collaborative-workflow-no-forks, eval=FALSE}
DiagrammeR::grViz("digraph {
repo -> new_branch -> pr -> accepted -> repo
}")
```

For fork-based workflows, the steps are to:

1. Create a fork of the main repository (if it hasn't been forked already).
1. Optionally but strongly recommended, create a new branch in the forked repository.
1. Make edits and changes to the files and commit to the branch.
1. When ready, submit a pull request. Changes may be requested, which require going
back to step 3.
1. If the pull request gets accepted and merged, the main branch in the main
repository is now updated and the new branch in the forked repository can be
deleted.
1. The forked repository now needs to be synchronized with the main repository.

```{r fig-git-collaborative-workflow-forks, eval=FALSE}
DiagrammeR::grViz("digraph {
sami_repo -> amira_fork -> amira_new_branch -> pr_to_sami_repo -> 
    pr_accepted -> sami_repo -> synch -> amira_fork
}")
```

The main differences between using a non-forked-based approach compared to a
forked-based approach is determined by whether you have access to modify ("write
permissions") the main repository. Usually if you are in a team, you have
permissions to modify and save ("write") changes to the main repository,
so in that case you would use a non-forked-based approach.

One challenge that often comes up is knowing how and when to use the branches.
Do you do all your changes there and make pull requests to the main branch
occasionally? Do you make a branch, do a pull request, and delete it right
after? What changes do you make in the new branch? These and many more are great
questions to ask and are also difficult to answer. They depend on context, on
the team, on the package you are making, what your aims are for the package, and
so on. However, there are a few tips to give:

1. Make small, focused changes that relate to a bug or specific goal (e.g.
updating documentation to reflect a spelling change) when making
new branches and submitting pull requests. The less you change, the easier it is
for the maintainer or your team members to review and accept.
1. If you are making big changes, its best to keep the changes related to a concept
or goal so that reviewing it is at least easier to conceptually follow.
1. Make changes related to a specific Issue and write in the Issue that you are
working on it.

Let's show some examples of how you'd use the fork and non-fork based workflows
based on a few scenarios.

1. **As a solo developer**: In this scenario, you would probably be least
likely to use this workflow since you can easily work with Git without ever making
a branch. However, sometimes you might want to experiment with code or text
and don't want to modify the main branch. Here you'd use the *non-fork-based workflow*.
1. **As a solo developer with some outside contributors**: If you are working on
an open source R package and people are occasionally contributing to your package,
as the maintainer and developer you would be dealing with other peoples pull
requests rather than you doing them yourself. If your package becomes very popular,
you might start using the *non-fork-based workflow* in order to reduce the chance
that you make a change to the main branch of the package that might affect
others who are using it.
1. **As a contributor but not part of a team**: If you contribute occasionally to
an R package, you would use the *fork-based workflow*. You would fork the package's
repository, make edits in new branches, and submit pull requests so your changes
get incorporated back into the package. This particular scenario is by far the most
commonly occurring in the open source R package world, since most packages are
maintained by one or many a few other people.
1. **As a member of a team**: If you have write permissions to the repository
and are part of a team working on that repository, you would use the *non-fork-based
workflow*. You'd make changes to files by first making a branch and when you are
ready, you would submit the changes as a pull request so other team members
can review your changes.

For the rest of this chapter we'll largely focus around the third and fourth scenarios.

### Exercise: Reading and comprehension task?

<!-- For pull requests, branches, and/or remotes? -->

### Exercise: What workflow do these situations need?

Consider these situations and think about the workflow you'd use for each of them.

1. You are in a class where one of the assignments is a group-based assignment
to make a software package. Which of the above workflows would be the best
approach to use to complete a project as a team? Can you think of other
approaches that might work just as well? What are some strengths and weaknesses
to each approach?
2. You are doing a MSc research project and you are mostly the only one who
works on the project. The other collaborators mainly provide intellectual
feedback and comments. What type of workflow would you use? Why? What other
workflows can you think of that might also work?
2. A friend learns that you are creating an R package in your free time and
wants to contribute. What would you tell your friend to do in order to
contribute? Which approach would work best for you, considering they may likely
work on your project occasionally and may only contribute a little bit?
3. While browsing a website for an R package, you find a few typos and decide to
fix it for them. Which of the above approaches would you use?

### Exercise: Consider some situations that would benefit from using PRs

Concept and thought, not code based.

## Securing your GitHub

<!-- This section won't be a code along, maybe reading activity? -->

TODO: This section might be moved up to the solo section, since that is when GitHub is first used

Any interaction with the Internet carries some risk to malicious activities and
threats. This is no different when using GitHub. Considering that most if not
all of your Git repositories will (now or eventually) be on GitHub, keep them
secured is a vital step when working online. Not only is it something that
should be done, but many usethis functions require these security features to be
set up in order to work. Thankfully making your GitHub account secure is a
fairly straightforward task and is made easier by the usethis functions
`gh_token_help()` and `create_github_token()`.
The usethis package website also has a really [well written guide][usethis-git-credentials] on setting it up.
Their (and our) basic recommendation is to:

- Use HTTPS with your GitHub TODO: explain this a bit more (e.g. vs SSH)
- Turn on two-factor authentication (2FA)
- Use personal access tokens (PAT) when interacting with your GitHub remote
repositories while outside of the GitHub website (e.g. when using R or usethis)
- Use a password manager to save the PAT for later use
- Use packages like gitcreds to let usethis access the PAT and interact with
your GitHub repositories
- Don't save your PAT in plain text files like `.Renviron` (which is/was often done)

[usethis-git-credentials]: https://usethis.r-lib.org/articles/articles/git-credentials.html

Next we provide some context and a rationale for these recommendations. In the following section, we explain how to actually implement this.

```{r cs-git-sitrep}
usethis::git_sitrep()
usethis::gh_token_help()
```

```{r}
gitcreds::gitcreds_set()
```

```{r ce-LABEL-NAME, eval=FALSE}
# TODO: need code to change working directory/project with local user name and run git_sitrep
# But this doesn't work because of sitrep uses global, not local..
# A workaround is to set the global user to be Amira in the GH Actions (e.g. `with:`)
# https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs
# TODO: Add code that detects if running on GitHub Actions, maybe an environment variable?
withr::with_dir(tempdir(),
{
    fs::file_create(".here")
    gert::git_init()
    gert::git_config_set("user.name", "Amira")
    fs::dir_ls(".", recurse = TRUE)
})
```

- usethis::create_github_token()
- gitcreds::gitcreds_set(), everytime computer restarts, only saved for session

### Exercises: Conceptual understanding of PAT, tokens, and password managers (non-coding)

### Exercises: Setting up PAT, saving PAT, using gitcreds at start of session

```{r es-LABEL-NAME}
# Code for exercise and shown to learner
```

```{r ee-LABEL-NAME}
# If needed. Code for exercise, NOT shown to learner, used for auto building of package/book
```

```{r sol-LABEL-NAME}
# Code for exercise *solution*, NOT shown to learner, (maybe) used for auto building of package/book
```

## Simplified collaboration with usethis

Collaborating through GitHub with forks, branches, and pull requests is
generally pretty easy when you've learned how to do use them. But even then, 
sometimes it can be a bit tedious having to click through all the clicks
to either submit a new pull request or to review, accept, and merge changes.
Thankfully, the usethis package has several helper functions specifically
designed to work with pull requests and collaborating through GitHub.
These functions all start with `pr_`, which stands for Pull Request.

What is the advantage of using the usethis PR helpers over using the GitHub 
interface? Once you learn to use these helpers, the biggest advantage is that
you will be faster at contributing to a project or dealing with contributions
since you won't have to leave RStudio. And, since the usethis functions are well
documented, you can read the help documents to remind yourself what to do and
how they work.

In Section \@ref(workflows-explained), we covered the different scenarios you'd
likely encounter while developing R packages and the accompanying workflows
you'd use. The usethis PR helpers are largely designed to help with scenarios
that involve either contributors to your project, you contributing to someone
else's project, or working within a team setting. You can also use these helpers
as a solo developer, but they are designed specifically for multi-person
contributing.

There are two roles that can be taken 
The usethis PR helper functions can be broadly grouped into several categories:

- Starting a contributing and submitting a pull request:
    - `pr_init()`
    - `pr_push()`
    - `pr_pause()`
- Receiving comments
- `pr_resume()`
- `pr_view()`
- `pr_merge_main()`
- `pr_pull()`

- `pr_finish()`
- `pr_forget()`

- `pr_fetch()`

- As contributor/sole developer/as team
    - usethis::pr_init()
        - Make changes to Contributing about using pr helpers
    - usethis::pr_push()
    - usethis::pr_view()
    - usethis::pr_pause()
    - Exercise: Make an edit on the PR changed files using GitHubs edit interface.
    - Exercise: Create another PR for adding ...FIXME.
    - usethis::pr_resume()
    - usethis::pr_pull()
    - usethis::pr_merge_main()
    - usethis::pr_push()
    - PR has been merged
    - gert::git_branch_list() # Show list of created branches
    - usethis::pr_finish()
    - Exercise: Do the same process for the other PR you had created.
    - gert::git_branch_list() # Show list of created branches
    - usethis::pr_init()
    - usethis::pr_forget()
    - gert::git_branch_list() # Show list of created branches

**Removing a branch**

- gert::git_branch_list() # Show list of created branches
- usethis::pr_init()
- usethis::pr_forget()
- gert::git_branch_list() # Show list of created branches

### Exercise: Deleting a branch without merging

TODO: Taken from PyRSE, needs more modifying.

Create a branch called `experiment` with pr_init(). Create a new vignette
called `experiment.Rmd` with use_article(). Add your name to the YAML header.
Commit the changes and move back to main branch with pr_pause().

1.  Run pr_forget()...

### Workflows for project maintainers or team leads

- As maintainer, reviewer, team lead. (Hard to do exercises for this... need to
think how this part would be implemented/practiced.)
    - usethis::pr_view()
    - usethis::pr_fetch()
    - usethis::pr_push()
    - usethis::pr_merge_main()
    - usethis::pr_view()
    - Manually merge PR.
    - usethis::pr_finish()
    - Exercise: Conceptual, write out/describe how this process could improve
    collaboration and teamwork.

```{r, eval=FALSE}
# NOTE: This is some of the code used throughout the chapter, put in a format
# that any changes to the project can be automatically added at final book build.
library(usethis)

# create_github_token()
# gitcreds::
# TODO: Talk about security?
# gh_token_help()

# TODO: Add to CONTRIBUTING guidelines about using usethis pr
pr_init("contributing-update")

# Not added to code, but added to text. Using this so package gets built exactly
# as stated in content.
# contributing_text <- readLines(here::here("CONTRIBUTING.md")) # Yea?
contribute_pr_helpers_text <- "
TODO: Add text about using usethis
"
# writeLines(contribute_pr_helpers_text, here::here("CONTRIBUTING.md"))

# gert::git_add("CONTRIBUTING.md")
# gert::git_commit("add to use usethis pr_ helpers in contributing")

# pr_push()
# Go into GitHub and merge PR (R function to do that? pr_fetch? git_merge then
# git_push?)

# pr_init("another-branch") # TODO: other changes?
# pr_pause()
# Someone reviews the PR and accepts it
# pr_resume("another-branch")
# 
# pr_finish()
```

## Chapter summary



## Final exercise {#11-final-exercise}

Complete these tasks as part of the package for your first project assignment.
Refer to the project assignment TODO: Add ref to assignment here?
for more details. As with the other final exercises,
we will use the `kenyaweather` package as an example and reference.
Don't forget to add and commit any changes you've made into the Git history
after each task, and pushing to GitHub.

TODO: Add guidelines about using usethis::pr_ helpers? or at least link to it?

1. Create a new Issue on your package's GitHub repository about an idea for a
function or to fix an existing function (you don't have to actually fix it).
2. Using the `pr_*` helpers, create a new branch called `fixing-function` using
`pr_init("fixing-function")`.
    - Make the following changes to the FIXME function:
        - FIXME: Not really sure what to say here. Could indicate that instructor has more detailed instructions. OR maybe not. Let's come back to this.
    - Add and commit these changes.
5. Push the changes up to GitHub by using `pr_push()`.
    - Create a new Pull Request based on the push in the newly opened up GitHub
    page (this should open automatically with `pr_push()`).
    - Merge the newly created Pull Request.
6. In your local Git repository, run `pr_finish()` to finish up.

Repeat this process one more time by making changes to:

- FIXME: Adding to README maybe or one of the vignettes?

```{r, eval=FALSE}
# This is the actions done to the project package
# 1. new issue
# githubr::gh_new_issue ? or gh package?
# new_number <- githubr::gh_issue_list ?

# 2. 
# pr_init("fixing-function")

# 3. 
# TODO: What to change?

# 4.
# git_add("R/TODO")
# git_commit(str_c("update function to have TODO. Closes ", new_number))

# 5.
# pr_push()
# pr_pause()
# git_merge("fixing-function")
# git_push() ?
# pr_resume("fixing-function")
# pr_finish()
```

### Exercises for second project assignment?

